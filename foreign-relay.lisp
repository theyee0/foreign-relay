;;;; foreign-relay.lisp

(in-package #:foreign-relay)

(defun print-welcome-message (window)
  (let ((y 0))
    (setf y (print-words window "Welcome to Foreign Relay, a game where you play the role of a relay station that intercepts letters and reformats them in non-corrupted form to pass them on. You will be responsible for identifying the keywords of the scrambled letter!" 0 0))
    (setf y (print-words window "You are able to enter things in the field at the bottom line by line. Once you receive a letter, you can start typing notes. They won't be considered until you type <start> and the program will consider all words until <end>" 0 y))
    (setf y (print-words window "Got it? Best of luck!" 0 y))
    (setf y (print-words window "Press any key to start the game..." 0 y))
    (charms:get-char window)
    (charms:clear-window window)))

(defun random-civilization (civilization-list)
  (aref civilization-list (random (length civilization-list))))

(defun main ()
  (setf *random-state* (make-random-state t))
  (charms:with-curses ()
    (charms:refresh-window charms:*standard-window*)
    (if (verify-size)
        (multiple-value-bind (info letter echo entry) (make-interface)
          (print-welcome-message info)
          (let ((info-line 0)
                (command "")
                (civilizations (generate-civilizations *random-state*)))
            (loop :while (setf command (get-input entry))
                  :do
                     (charms:clear-window letter)
                     (charms:clear-window echo)
                     (let ((sender (random-civilization civilizations))
                           (address (random-civilization civilizations)))
                       (setf info-line (print-words info (uiop:split-string "Decoding a letter!" :separator " ") 0 info-line))
                       (multiple-value-bind (message keywords) (generate-message sender address *random-state*)
                         (print-letter message letter
                                       (if (eq (civilization-technology sender) :digital)
                                           (lambda (x) (corruption:corrupt-string x *random-state*))
                                           (lambda (x) (corruption:corrupt-writing x 0.03 *random-state*))))
                         (let ((correct (get-context entry echo keywords))
                               (total (num-keywords keywords)))
                           (if (< correct (random total *random-state*))
                               (update-relationship sender :succeeded *random-state*)
                               (update-relationship sender :failed *random-state*))))))))
        (format t "A terminal width of at least 80x25 is required!~%")))
  (format t "Program ended. Hope to see you next time...~%"))
